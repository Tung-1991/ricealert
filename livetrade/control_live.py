# livetrade/control_live.py
# -*- coding: utf-8 -*-
# Version: 7.4.0 - FINAL FIX

import os
import sys
import json
import uuid
import time
import requests
import pytz
import pandas as pd
import traceback
import shutil
import signal
from datetime import datetime, timedelta

# --- C·∫§U H√åNH ƒê∆Ø·ªúNG D·∫™N ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(BASE_DIR)
sys.path.append(PROJECT_ROOT)

try:
    from binance_connector import BinanceConnector
    from indicator import calculate_indicators
    from live_trade import (
        TRADING_MODE, GENERAL_CONFIG, TACTICS_LAB,
        INTERVALS_TO_SCAN, RISK_RULES_CONFIG,
        calculate_total_equity, build_dynamic_alert_text, build_daily_summary_text,
        send_discord_message_chunks, ALERT_CONFIG,
        determine_market_zone_with_scoring, get_mtf_adjustment_coefficient,
        indicator_results, price_dataframes,
        get_price_data_with_cache,
        close_trade_on_binance,
        export_trade_history_to_csv
    )
    from trade_advisor import get_advisor_decision, FULL_CONFIG as ADVISOR_BASE_CONFIG
except ImportError as e:
    sys.exit(f"‚ùå L·ªói: Kh√¥ng th·ªÉ import module c·∫ßn thi·∫øt: {e}.")

# --- C√ÅC H·∫∞NG S·ªê ---
DATA_DIR = os.path.join(BASE_DIR, "data")
STATE_FILE = os.path.join(DATA_DIR, "live_trade_state.json")
TRADE_HISTORY_CSV_FILE = os.path.join(DATA_DIR, "live_trade_history.csv")
LOCK_FILE = STATE_FILE + ".lock"
ENV_FILE = os.path.join(PROJECT_ROOT, ".env")
VIETNAM_TZ = pytz.timezone('Asia/Ho_Chi_Minh')
TACTICS = list(TACTICS_LAB.keys())
INTERVALS = list(INTERVALS_TO_SCAN)

# --- C√ÅC H√ÄM TI·ªÜN √çCH & KH√ìA FILE ---
def format_price_dynamically(price: float) -> str:
    if price is None or pd.isna(price): return "N/A"
    try:
        price_f = float(price)
        if price_f >= 1.0: return f"${price_f:,.4f}"
        return f"${price_f:,.8f}"
    except (ValueError, TypeError):
        return "N/A"

def acquire_lock(timeout=120):
    start_time = time.time()
    print("‚è≥ ƒêang ch·ªù quy·ªÅn truy c·∫≠p file tr·∫°ng th√°i...", end='', flush=True)
    while os.path.exists(LOCK_FILE):
        if time.time() - start_time > timeout:
            print(f"\r‚ùå L·ªói: Kh√¥ng th·ªÉ chi·∫øm quy·ªÅn ƒëi·ªÅu khi·ªÉn file sau {timeout} gi√¢y.")
            return False
        time.sleep(0.5); print(".", end='', flush=True)
    try:
        with open(LOCK_FILE, 'w') as f: f.write(str(os.getpid()))
        print("\r‚úÖ ƒê√£ c√≥ quy·ªÅn truy c·∫≠p.                                       ")
        return True
    except IOError as e: print(f"\r‚ùå L·ªói I/O khi t·∫°o file lock: {e}"); return False

def release_lock():
    if os.path.exists(LOCK_FILE):
        try: os.remove(LOCK_FILE)
        except OSError as e: print(f"‚ùå L·ªói khi gi·∫£i ph√≥ng file lock: {e}")

def create_backup(state_file_path):
    try:
        if os.path.exists(state_file_path):
            shutil.copy2(state_file_path, state_file_path + ".backup")
            print("üìã ƒê√£ t·∫°o b·∫£n sao l∆∞u an to√†n (`.backup`).")
    except Exception as e: print(f"‚ö†Ô∏è C·∫£nh b√°o: Kh√¥ng th·ªÉ t·∫°o file sao l∆∞u. L·ªói: {e}")

def handle_exit_signals(signum, frame):
    print(f"\nüö® Nh·∫≠n ƒë∆∞·ª£c t√≠n hi·ªáu ng·∫Øt. ƒêang d·ªçn d·∫πp v√† tho√°t...")
    release_lock()
    sys.exit(1)

def parse_env_variable(key_name):
    try:
        with open(ENV_FILE, 'r') as f:
            for line in f:
                if line.strip() and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    if key.strip() == key_name:
                        return [item.strip() for item in value.strip().strip('"').strip("'").split(',')]
    except FileNotFoundError: print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file .env t·∫°i {ENV_FILE}"); return []
    return []

def get_current_price(symbol):
    url = f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}"
    try: return float(requests.get(url, timeout=5).json()['price'])
    except Exception: return None

def get_usdt_fund(bnc: BinanceConnector):
    try:
        balance_info = bnc.get_account_balance()
        usdt = next((b for b in balance_info.get("balances", []) if b["asset"] == "USDT"), None)
        if usdt: return float(usdt['free']), float(usdt['free']) + float(usdt['locked'])
    except Exception as e: print(f"‚ö†Ô∏è L·ªói kh√¥ng th·ªÉ l·∫•y s·ªë d∆∞ USDT: {e}"); return 0.0, 0.0

def load_state():
    if not os.path.exists(STATE_FILE): return {"active_trades": [], "trade_history": []}
    try:
        with open(STATE_FILE, 'r', encoding='utf-8') as f:
            content = f.read()
            return json.loads(content) if content else {"active_trades": [], "trade_history": []}
    except Exception as e: print(f"‚ùå L·ªói khi ƒë·ªçc file tr·∫°ng th√°i: {e}"); return None

def save_state(state):
    try:
        temp_keys = ['temp_newly_opened_trades', 'temp_newly_closed_trades', 'temp_money_spent_on_trades', 'temp_pnl_from_closed_trades', 'session_has_events']
        state_to_save = {k: v for k, v in state.items() if k not in temp_keys}
        with open(STATE_FILE, 'w', encoding='utf-8') as f: json.dump(state_to_save, f, indent=4, ensure_ascii=False)
        print("\n‚úÖ ƒê√£ l∆∞u l·∫°i tr·∫°ng th√°i (state.json) th√†nh c√¥ng!")
    except Exception as e: print(f"‚ùå L·ªói khi l∆∞u file tr·∫°ng th√°i: {e}")

def select_from_list(options, prompt, display_list):
    if not options: return None
    for i, item in enumerate(display_list): print(f"  {i+1}. {item}")
    while True:
        try:
            choice_str = input(prompt)
            if not choice_str: return None
            choice = int(choice_str)
            if 1 <= choice <= len(options): return options[choice - 1]
            else: print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.")
        except ValueError: print("‚ö†Ô∏è Vui l√≤ng nh·∫≠p m·ªôt con s·ªë.")

def reconcile_state(bnc: BinanceConnector, state: dict):
    if not state or not state.get("active_trades"): return [], []
    try:
        balances = {item['asset']: float(item['free']) + float(item['locked']) for item in bnc.get_account_balance().get("balances", [])}
    except Exception as e: print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y s·ªë d∆∞ ƒë·ªÉ ƒë·ªëi so√°t: {e}"); return state.get("active_trades", []), []
    valid, desynced = [], []
    threshold = GENERAL_CONFIG.get("RECONCILIATION_QTY_THRESHOLD", 0.95)
    for trade in state.get("active_trades", []):
        asset = trade['symbol'].replace("USDT", "")
        if balances.get(asset, 0.0) < float(trade.get('quantity', 0)) * threshold:
            desynced.append(trade)
        else: valid.append(trade)
    return valid, desynced

# --- C√ÅC H√ÄM CH·ª®C NƒÇNG MENU ---

def refresh_market_data_for_panel():
    print("\n... ƒêang t·∫£i d·ªØ li·ªáu th·ªã tr∆∞·ªùng m·ªõi nh·∫•t...")
    all_symbols_in_env = parse_env_variable("SYMBOLS_TO_SCAN")
    if not all_symbols_in_env:
        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y symbol n√†o trong file .env ƒë·ªÉ t·∫£i d·ªØ li·ªáu.")
        return
    for symbol in all_symbols_in_env:
        indicator_results.setdefault(symbol, {})
        price_dataframes.setdefault(symbol, {})
        for interval in ["1h", "4h", "1d"]:
            df = get_price_data_with_cache(symbol, interval, GENERAL_CONFIG["DATA_FETCH_LIMIT"])
            if df is not None and not df.empty:
                indicator_results[symbol][interval] = calculate_indicators(df.copy(), symbol, interval)
                price_dataframes[symbol][interval] = df
    print("... T·∫£i d·ªØ li·ªáu ho√†n t·∫•t ...")

def show_full_dashboard(bnc: BinanceConnector):
    print("\n" + "="*80)
    print(f"üìä B√ÅO C√ÅO T·ªîNG QUAN & RADAR TH·ªä TR∆Ø·ªúNG - {datetime.now(VIETNAM_TZ).strftime('%H:%M %d-%m-%Y')} üìä")
    state = load_state()
    if not state: print("‚ùå Kh√¥ng th·ªÉ t·∫£i state."); return
    valid_trades, desynced_trades = reconcile_state(bnc, state)
    _, total_usdt = get_usdt_fund(bnc)
    prices = {s['symbol']: get_current_price(s['symbol']) for s in valid_trades}
    value_open = sum(float(t.get('quantity', 0)) * prices.get(t['symbol'], 0) for t in valid_trades if prices.get(t['symbol']))
    equity = total_usdt + value_open
    initial_capital = state.get('initial_capital', equity or 1)
    if initial_capital <= 0: initial_capital = 1
    pnl_total_usd = equity - initial_capital
    pnl_total_percent = (pnl_total_usd / initial_capital) * 100

    print(f"\nüí∞ V·ªën Bƒê: ${initial_capital:,.2f} | üíµ Ti·ªÅn m·∫∑t (USDT): ${total_usdt:,.2f}")
    print(f"üìä T·ªïng TS: ${equity:,.2f} | üìà PnL T·ªïng: {'üü¢' if pnl_total_usd >= 0 else 'üî¥'} ${pnl_total_usd:,.2f} ({pnl_total_percent:+.2f}%)")
    print("\n" + "---" * 10 + " üõ∞Ô∏è DANH S√ÅCH L·ªÜNH ƒêANG M·ªû üõ∞Ô∏è " + "---" * 10)
    all_trades = sorted(valid_trades + desynced_trades, key=lambda t: t.get('entry_time', ''))
    if not all_trades: print("‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh n√†o ƒëang m·ªü.");
    else:
        for trade in all_trades:
            is_desynced = any(t['trade_id'] == trade['trade_id'] for t in desynced_trades)
            symbol = trade.get('symbol', 'N/A')
            current_price = prices.get(symbol)
            pnl_usd, pnl_percent = 0, 0
            if current_price and not is_desynced:
                entry_price = trade.get('entry_price', 0)
                invested_usd = trade.get('total_invested_usd', 0)
                if entry_price > 0:
                    pnl_percent = ((current_price - entry_price) / entry_price) * 100
                    pnl_usd = invested_usd * (pnl_percent / 100)
                current_value = invested_usd + pnl_usd
                price_info = f"V·ªën: ${invested_usd:,.2f} ‚Üí ${current_value:,.2f} | Entry: {format_price_dynamically(entry_price)} | Cur: {format_price_dynamically(current_price)} | TP: {format_price_dynamically(trade.get('tp'))} | SL: {format_price_dynamically(trade.get('sl'))}"
            else:
                invested_usd = trade.get('total_invested_usd', 0)
                price_info = f"V·ªën: ${invested_usd:,.2f} | Entry: {format_price_dynamically(trade.get('entry_price'))} (Kh√¥ng th·ªÉ t√≠nh PnL)"

            try:
                entry_time = datetime.fromisoformat(trade.get('entry_time')).astimezone(VIETNAM_TZ)
                holding_hours = (datetime.now(VIETNAM_TZ) - entry_time).total_seconds() / 3600
                hold_display = f"| Gi·ªØ: {holding_hours:.1f}h"
            except:
                hold_display = ""

            pnl_icon = "‚ö™Ô∏è" if is_desynced else ("üü¢" if pnl_usd >= 0 else "üî¥")
            score_display = f"{trade.get('entry_score', 0.0):.1f}‚Üí{trade.get('last_score', 0.0):.1f}"
            entry_zone, last_zone = trade.get('entry_zone', 'N/A'), trade.get('last_zone')
            zone_display = f"{entry_zone}‚Üí{last_zone}" if last_zone and last_zone != entry_zone else entry_zone
            tactic_info = f"({trade.get('opened_by_tactic', 'N/A')} | {score_display} | {zone_display})"
            print(f"{pnl_icon}{' ‚ö†Ô∏è DESYNC' if is_desynced else ''} {symbol}-{trade.get('interval', 'N/A')} {tactic_info} PnL: ${pnl_usd:,.2f} ({pnl_percent:+.2f}%) {hold_display}")
            print(f"   {price_info}")

    if input("\nüëâ Hi·ªÉn th·ªã Radar th·ªã tr∆∞·ªùng? (y/n): ").lower() != 'y': print("="*80); return
    print("\n" + "---" * 10 + " üì° RADAR QU√âT TH·ªä TR∆Ø·ªúNG üì° " + "---" * 10)
    refresh_market_data_for_panel()
    symbols_to_scan = parse_env_variable("SYMBOLS_TO_SCAN")
    symbols_in_trades = {t['symbol'] for t in all_trades}

    if not symbols_to_scan: print("‚ÑπÔ∏è Kh√¥ng c√≥ symbol n√†o trong .env ƒë·ªÉ qu√©t.")
    else:
        for symbol in symbols_to_scan:
            trade_status_tag = " [M·ªû]" if symbol in symbols_in_trades else ""
            print(f"\n--- {symbol}{trade_status_tag} ---")
            price_str = "N/A"
            temp_indicators = indicator_results.get(symbol, {}).get("1h")
            if temp_indicators and temp_indicators.get('price'): price_str = format_price_dynamically(temp_indicators.get('price'))
            print(f"  Gi√° hi·ªán t·∫°i: {price_str}")
            for interval in ["1h", "4h", "1d"]:
                indicators = indicator_results.get(symbol, {}).get(interval)
                if not indicators: print(f"  [{interval}]: Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch."); continue
                zone = determine_market_zone_with_scoring(symbol, interval)
                best_raw_score, best_adj_score, best_tactic, entry_threshold, mtf_coeff = 0, 0, "N/A", "N/A", 1.0

                for tactic_name, tactic_cfg in TACTICS_LAB.items():
                    optimal_zones = tactic_cfg.get("OPTIMAL_ZONE", [])
                    if not isinstance(optimal_zones, list): optimal_zones = [optimal_zones]
                    if zone in optimal_zones:
                        decision = get_advisor_decision(symbol, interval, indicators, ADVISOR_BASE_CONFIG, weights_override=tactic_cfg.get("WEIGHTS"))
                        raw_score = decision.get("final_score", 0.0)
                        temp_mtf_coeff = get_mtf_adjustment_coefficient(symbol, interval)
                        adjusted_score = raw_score * temp_mtf_coeff
                        if adjusted_score > best_adj_score:
                            best_raw_score = raw_score
                            best_adj_score = adjusted_score
                            best_tactic = tactic_name
                            entry_threshold = tactic_cfg.get("ENTRY_SCORE", "N/A")
                            mtf_coeff = temp_mtf_coeff

                if best_raw_score == 0:
                    decision = get_advisor_decision(symbol, interval, indicators, ADVISOR_BASE_CONFIG)
                    best_raw_score = decision.get("final_score", 0.0)
                    mtf_coeff = get_mtf_adjustment_coefficient(symbol, interval)
                    best_adj_score = best_raw_score * mtf_coeff
                    best_tactic = "Default"

                is_strong_signal = isinstance(entry_threshold, (int, float)) and best_adj_score >= entry_threshold
                icon = "üü¢" if is_strong_signal else ("üü°" if best_adj_score >= 5.5 else "üî¥")
                mtf_display = f"x{mtf_coeff:.2f}"
                score_display = f"G·ªëc: {best_raw_score:.2f} | Cu·ªëi: {best_adj_score:.2f} (MTF {mtf_display})"
                print(f"  {icon} [{interval}]: Zone: {zone.ljust(10)} | {score_display} | Tactic: {best_tactic} (Ng∆∞·ª°ng: {entry_threshold})")
    print("="*80)


# D√°n ƒë√® h√†m n√†y v√†o control_live.py

def view_csv_history():
    print("\n--- üìú 20 Giao d·ªãch cu·ªëi c√πng (t·ª´ file CSV) üìú ---")
    try:
        if not os.path.exists(TRADE_HISTORY_CSV_FILE):
            print("‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y file trade_history.csv.")
            return
        df = pd.read_csv(TRADE_HISTORY_CSV_FILE)
        if df.empty:
            print("‚ÑπÔ∏è File l·ªãch s·ª≠ tr·ªëng.")
            return

        # T·∫°o c·ªôt datetime t·∫°m th·ªùi ƒë·ªÉ x·ª≠ l√Ω v√† s·∫Øp x·∫øp
        df['exit_time_dt'] = pd.to_datetime(df['exit_time'], errors='coerce')

        # L·ªçc b·ªè nh·ªØng d√≤ng kh√¥ng th·ªÉ parse ƒë∆∞·ª£c th·ªùi gian
        df_display = df.dropna(subset=['exit_time_dt']).copy()

        # <<< S·ª¨A L·ªñI LOGIC QUAN TR·ªåNG ·ªû ƒê√ÇY >>>
        # 1. S·∫ÆP X·∫æP TR∆Ø·ªöC khi l√†m b·∫•t c·ª© ƒëi·ªÅu g√¨ kh√°c, d√πng c·ªôt datetime object ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng th·ª© t·ª±
        df_sorted = df_display.sort_values(by='exit_time_dt', ascending=False).head(20)

        # 2. B√ÇY GI·ªú m·ªõi b·∫Øt ƒë·∫ßu format l·∫°i c√°c c·ªôt ƒë·ªÉ hi·ªÉn th·ªã cho ƒë·∫πp
        df_formatted = df_sorted.copy()
        
        df_formatted['Time Close'] = df_formatted['exit_time_dt'].dt.tz_convert(VIETNAM_TZ).dt.strftime('%m-%d %H:%M')
        
        for col in ['total_invested_usd', 'pnl_usd', 'pnl_percent', 'entry_price', 'exit_price', 'entry_score', 'last_score', 'holding_duration_hours']:
            if col in df_formatted.columns:
                df_formatted[col] = pd.to_numeric(df_formatted[col], errors='coerce')
        
        def get_initial_capital(row):
            try:
                initial_entry_str = row['initial_entry']
                if pd.isna(initial_entry_str) or not initial_entry_str: return row['total_invested_usd']
                initial_entry_data = json.loads(str(initial_entry_str).replace("'", "\""))
                return float(initial_entry_data.get('invested_usd', row['total_invested_usd']))
            except:
                return row['total_invested_usd']
        
        df_formatted['V·ªën'] = df_formatted.apply(get_initial_capital, axis=1).apply(lambda x: f"${x:,.2f}" if pd.notna(x) else "N/A")
        df_formatted['pnl_usd'] = df_formatted['pnl_usd'].apply(lambda x: f"${x:+.2f}" if pd.notna(x) else "N/A")
        df_formatted['PnL %'] = df_formatted['pnl_percent'].apply(lambda x: f"{x:+.2f}%" if pd.notna(x) else "N/A")
        df_formatted['Gi√° v√†o'] = df_formatted['entry_price'].apply(format_price_dynamically)
        df_formatted['Gi√° ra'] = df_formatted['exit_price'].apply(format_price_dynamically)
        df_formatted['Score'] = df_formatted.apply(lambda row: f"{row.get('entry_score', 0.0):.1f}‚Üí{row.get('last_score', 0.0):.1f}" if pd.notna(row.get('entry_score')) and pd.notna(row.get('last_score')) else "N/A", axis=1)
        df_formatted['Zone'] = df_formatted.apply(lambda row: f"{row.get('entry_zone', 'N/A')}‚Üí{row.get('last_zone', 'N/A')}" if pd.notna(row.get('entry_zone')) and pd.notna(row.get('last_zone')) else row.get('entry_zone', 'N/A'), axis=1)
        df_formatted.rename(columns={'holding_duration_hours': 'Hold (h)', 'opened_by_tactic': 'Tactic'}, inplace=True)

        # 3. CH·ªåN C√ÅC C·ªòT CU·ªêI C√ôNG ƒê·ªÇ IN RA
        final_order = ['Time Close', 'symbol', 'interval', 'Gi√° v√†o', 'Gi√° ra', 'V·ªën', 'pnl_usd', 'PnL %', 'Hold (h)', 'Score', 'Zone', 'Tactic', 'status']
        df_final_display = df_formatted[[c for c in final_order if c in df_formatted.columns]]

        print(df_final_display.to_string(index=False))
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi ƒë·ªçc file CSV: {e}"); traceback.print_exc()




def manual_report(bnc: BinanceConnector):
    print("\n" + "üìú" * 10 + " T·∫†O B√ÅO C√ÅO TH·ª¶ C√îNG " + "üìú" * 10)
    state = load_state()
    if not state: print("‚ùå Kh√¥ng th·ªÉ t·∫£i file tr·∫°ng th√°i."); return
    print("... ƒêang t√≠nh to√°n d·ªØ li·ªáu b√°o c√°o...")
    available_usdt, total_usdt = get_usdt_fund(bnc)
    realtime_prices = {t['symbol']: get_current_price(t['symbol']) for t in state.get('active_trades', []) if t.get('symbol')}
    equity = calculate_total_equity(state, total_usdt, realtime_prices)
    if equity is None: print("‚ùå Kh√¥ng th·ªÉ t√≠nh t·ªïng t√†i s·∫£n do l·ªói API. Vui l√≤ng th·ª≠ l·∫°i."); return
    print("\nCh·ªçn lo·∫°i b√°o c√°o:"); print("  1. B√°o c√°o ƒê·ªông (Dynamic - Ng·∫Øn g·ªçn)"); print("  2. B√°o c√°o T·ªïng k·∫øt (Daily - Chi ti·∫øt)")
    report_choice = input("üëâ L·ª±a ch·ªçn c·ªßa b·∫°n (Enter ƒë·ªÉ h·ªßy): ")
    report_content = ""
    if report_choice == '1': report_content = build_dynamic_alert_text(state, total_usdt, available_usdt, realtime_prices, equity)
    elif report_choice == '2':
        state.update({'temp_newly_opened_trades': [], 'temp_newly_closed_trades': []})
        report_content = build_daily_summary_text(state, total_usdt, available_usdt, realtime_prices, equity)
    else: return
    print("\n" + "="*80); print(report_content); print("="*80)
    if ALERT_CONFIG.get("DISCORD_WEBHOOK_URL") and input("\nüëâ G·ª≠i b√°o c√°o n√†y l√™n Discord? (y/n): ").lower() == 'y':
        print("... ƒêang g·ª≠i l√™n Discord..."); send_discord_message_chunks(report_content, force=True); print("‚úÖ ƒê√£ g·ª≠i.")

def show_tactic_analysis():
    print("\n" + "="*15, "üìä B·∫¢NG PH√ÇN T√çCH HI·ªÜU SU·∫§T TACTIC üìä", "="*15)
    if not os.path.exists(TRADE_HISTORY_CSV_FILE):
        print("‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y file trade_history.csv.")
        return
    try:
        df = pd.read_csv(TRADE_HISTORY_CSV_FILE)
        df['pnl_usd'] = pd.to_numeric(df['pnl_usd'], errors='coerce')
        df.dropna(subset=['pnl_usd', 'opened_by_tactic'], inplace=True)
        df = df[df['status'].str.contains('Closed', na=False, case=False)]

        if df.empty:
            print("‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá ƒë·ªÉ ph√¢n t√≠ch hi·ªáu su·∫•t.")
            return

        grouped = df.groupby('opened_by_tactic').agg(
            Total_Trades=('pnl_usd', 'count'),
            Total_PnL=('pnl_usd', 'sum'),
            Wins=('pnl_usd', lambda x: (x > 0).sum()),
            Avg_Win_PnL=('pnl_usd', lambda x: x[x > 0].mean()),
            Avg_Loss_PnL=('pnl_usd', lambda x: x[x <= 0].mean()),
            # S·ª≠a l·ªói c√∫ ph√°p ·ªü ƒë√¢y: D√πng t√™n h·ª£p l·ªá, kh√¥ng c√≥ k√Ω t·ª± '$'
            Max_Win=('pnl_usd', lambda x: x[x > 0].max()),
            Max_Loss=('pnl_usd', lambda x: x[x <= 0].min())
        ).fillna(0)

        grouped['Win_Rate_%'] = (grouped['Wins'] / grouped['Total_Trades'] * 100).where(grouped['Total_Trades'] > 0, 0)
        grouped['Payoff_Ratio'] = abs(grouped['Avg_Win_PnL'] / grouped['Avg_Loss_PnL']).where(grouped['Avg_Loss_PnL'] != 0, float('inf'))
        win_rate = grouped['Wins'] / grouped['Total_Trades']
        loss_rate = 1 - win_rate
        grouped['Expectancy_$'] = (win_rate * grouped['Avg_Win_PnL']) + (loss_rate * grouped['Avg_Loss_PnL'])

        total_row = {
            'Tactic': 'T·ªîNG C·ªòNG',
            'Total_Trades': df.shape[0],
            'Total_PnL': df['pnl_usd'].sum(),
            'Wins': (df['pnl_usd'] > 0).sum(),
            'Avg_Win_PnL': df[df['pnl_usd'] > 0]['pnl_usd'].mean(),
            'Avg_Loss_PnL': df[df['pnl_usd'] <= 0]['pnl_usd'].mean(),
            'Max_Win': df[df['pnl_usd'] > 0]['pnl_usd'].max(),
            'Max_Loss': df[df['pnl_usd'] <= 0]['pnl_usd'].min()
        }
        total_row['Win_Rate_%'] = (total_row['Wins'] / total_row['Total_Trades'] * 100) if total_row['Total_Trades'] > 0 else 0
        total_row['Payoff_Ratio'] = abs(total_row['Avg_Win_PnL'] / total_row['Avg_Loss_PnL']) if total_row.get('Avg_Loss_PnL') and total_row['Avg_Loss_PnL'] != 0 else float('inf')
        total_win_rate_frac = total_row['Wins'] / total_row['Total_Trades'] if total_row['Total_Trades'] > 0 else 0
        total_row['Expectancy_$'] = (total_win_rate_frac * total_row.get('Avg_Win_PnL', 0)) + ((1 - total_win_rate_frac) * total_row.get('Avg_Loss_PnL', 0))

        total_df = pd.DataFrame([total_row]).set_index('Tactic')
        analysis_df = pd.concat([grouped, total_df.fillna(0)])

        final_df = analysis_df.reset_index().rename(columns={'index': 'Tactic'})

        # ƒê·ªïi t√™n c·ªôt ·ªü b∆∞·ªõc cu·ªëi c√πng ƒë·ªÉ hi·ªÉn th·ªã, tr√°nh l·ªói c√∫ ph√°p
        final_df.rename(columns={'Max_Win': 'Max_Win_$', 'Max_Loss': 'Max_Loss_$'}, inplace=True)
        final_cols = ['Tactic', 'Total_Trades', 'Win_Rate_%', 'Total_PnL', 'Expectancy_$', 'Payoff_Ratio', 'Avg_Win_PnL', 'Avg_Loss_PnL', 'Max_Win_$', 'Max_Loss_$']

        pd.options.display.float_format = '{:,.2f}'.format
        print("Ch√∫ th√≠ch:")
        print("  - Expectancy_$: L·ª£i nhu·∫≠n k·ª≥ v·ªçng cho m·ªói l·∫ßn v√†o l·ªánh b·∫±ng Tactic n√†y.")
        print("  - Payoff_Ratio: Khi th·∫Øng, b·∫°n ƒÉn ƒë∆∞·ª£c g·∫•p bao nhi√™u l·∫ßn so v·ªõi khi thua.")
        print("-" * 60)
        print(final_df[final_cols].to_string(index=False))
        pd.options.display.float_format = None
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi ph√¢n t√≠ch file CSV: {e}")
        traceback.print_exc()
    print("="*80)


def open_manual_trade(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        print("\n" + "üî•" * 10 + " M·ªû L·ªÜNH M·ªöI TH·ª¶ C√îNG " + "üî•" * 10)
        state = load_state()
        if state is None: return

        available_symbols = parse_env_variable("SYMBOLS_TO_SCAN")
        if not available_symbols: print("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc symbol t·ª´ .env."); return
        symbol = select_from_list(available_symbols, "üëâ Ch·ªçn Symbol (Enter ƒë·ªÉ h·ªßy): ", available_symbols)
        if not symbol: return
        interval = select_from_list(INTERVALS, "üëâ Ch·ªçn Interval (Enter ƒë·ªÉ h·ªßy): ", INTERVALS)
        if not interval: return
        tactic_name = select_from_list(TACTICS, "üëâ Ch·ªçn Tactic (Enter ƒë·ªÉ h·ªßy): ", TACTICS)
        if not tactic_name: return
        tactic_cfg = TACTICS_LAB.get(tactic_name, {})

        available_usdt, _ = get_usdt_fund(bnc)
        print(f"üíµ USDT kh·∫£ d·ª•ng: ${available_usdt:,.2f}")
        invested_amount = float(input(f"üëâ Nh·∫≠p v·ªën USDT: "))
        min_order_val = GENERAL_CONFIG.get('MIN_ORDER_VALUE_USDT', 11.0)
        if invested_amount > available_usdt or invested_amount < min_order_val:
            print(f"‚ùå V·ªën kh√¥ng h·ª£p l·ªá (Ph·∫£i <= ${available_usdt:,.2f} v√† >= ${min_order_val})."); return

        if input(f"‚ö†Ô∏è ƒê·∫∑t l·ªánh MUA {symbol} v·ªõi ${invested_amount:,.2f}? (y/n): ").lower() != 'y': return

        create_backup(STATE_FILE)

        order = bnc.place_market_order(symbol=symbol, side="BUY", quote_order_qty=round(invested_amount, 2))
        if not (order and float(order.get('executedQty', 0)) > 0):
            raise Exception("L·ªánh kh√¥ng kh·ªõp ho·∫∑c kh√¥ng c√≥ ph·∫£n h·ªìi.")

        qty, cost = float(order['executedQty']), float(order['cummulativeQuoteQty'])
        price = cost / qty if qty > 0 else 0
        sl_price = price * (1 - RISK_RULES_CONFIG["MAX_SL_PERCENT_BY_TIMEFRAME"].get(interval, 0.08))
        tp_price = price + ((price - sl_price) * tactic_cfg.get("RR", 2.0))

        new_trade = {
            "trade_id": str(uuid.uuid4()), "symbol": symbol, "interval": interval, "status": "ACTIVE",
            "opened_by_tactic": tactic_name, "trade_type": "LONG", "entry_price": price,
            "quantity": qty, "tp": tp_price, "sl": sl_price, "initial_sl": sl_price,
            "initial_entry": {"price": price, "quantity": qty, "invested_usd": cost},
            "total_invested_usd": cost, "entry_time": datetime.now(VIETNAM_TZ).isoformat(),
            "entry_score": 5.0, "last_score": 5.0, "entry_zone": "Manual", "last_zone": "Manual",
            "tactic_used": ["Manual_Entry"], "binance_market_order_id": order['orderId'],
            "dca_entries": [], "realized_pnl_usd": 0.0,
        }
        state['active_trades'].append(new_trade)
        state['money_spent_on_trades_last_session'] = state.get('money_spent_on_trades_last_session', 0.0) + cost

        save_state(state)
        print(f"‚úÖ ƒê√£ th√™m l·ªánh {symbol} th√†nh c√¥ng v√† c·∫≠p nh·∫≠t s·ªï s√°ch.")

    except (ValueError, TypeError): print("‚ùå Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.")
    except Exception as e: print(f"‚ùå L·ªói: {e}"); traceback.print_exc()
    finally: release_lock()

def close_manual_trade(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        state = load_state()
        if not state: return
        # M·∫•y d√≤ng n√†y kh√¥ng c·∫ßn thi·∫øt n·∫øu state ƒë∆∞·ª£c qu·∫£n l√Ω t·ªët, nh∆∞ng c·ª© ƒë·ªÉ cho ch·∫Øc
        state.setdefault('money_gained_from_trades_last_session', 0.0)
        state.setdefault('temp_pnl_from_closed_trades', 0.0)

        valid_trades, _ = reconcile_state(bnc, state)
        if not valid_trades:
            print("‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh h·ª£p l·ªá ƒë·ªÉ ƒë√≥ng.")
            return

        display_list = [f"{t['symbol']}-{t['interval']} (V·ªën: ${t.get('total_invested_usd', 0):.2f})" for t in valid_trades]
        trade_to_close = select_from_list(valid_trades, "üëâ Ch·ªçn l·ªánh c·∫ßn ƒë√≥ng (Enter ƒë·ªÉ h·ªßy): ", display_list)
        if not trade_to_close:
            print("H·ªßy thao t√°c.")
            return

        create_backup(STATE_FILE)
        print(f"‚ö°Ô∏è ƒêang y√™u c·∫ßu ƒë√≥ng l·ªánh {trade_to_close['symbol']}...")
        
        # H√†m close_trade_on_binance b√™n live_trade.py s·∫Ω t·ª± lo vi·ªác ghi CSV
        # M√¨nh ch·ªâ c·∫ßn g·ªçi n√≥ v√† save state l√† ƒë·ªß.
        success = close_trade_on_binance(bnc, trade_to_close, "Panel Manual", state, close_pct=1.0)

        if success:
            print(f"‚úÖ Y√™u c·∫ßu ƒë√≥ng {trade_to_close['symbol']} ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng.")
            # ### B·ªé ƒêO·∫†N N√ÄY ƒêI, N√ì G√ÇY DUPLICATE ###
            # closed_trade_data = next((t for t in reversed(state.get('trade_history', [])) if t['trade_id'] == trade_to_close['trade_id']), None)
            # if closed_trade_data:
            #      export_trade_history_to_csv([closed_trade_data])
            # ###########################################
            save_state(state) # Ch·ªâ c·∫ßn l∆∞u state l√† ƒë·ªß
        else:
            print(f"‚ùå X·ª≠ l√Ω y√™u c·∫ßu ƒë√≥ng {trade_to_close['symbol']} th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra log.")
    finally: release_lock()


def close_all_trades(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        state = load_state()
        if not state: return
        state.setdefault('money_gained_from_trades_last_session', 0.0)
        state.setdefault('temp_pnl_from_closed_trades', 0.0)
        valid_trades, _ = reconcile_state(bnc, state)
        if not valid_trades:
            print("‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh h·ª£p l·ªá ƒë·ªÉ ƒë√≥ng.")
            return
        if input(f"‚ö†Ô∏è C·∫¢NH B√ÅO: S·∫Ω ƒë√≥ng {len(valid_trades)} l·ªánh. Ti·∫øp t·ª•c? (y/n): ").lower() != 'y':
            print("H·ªßy thao t√°c.")
            return

        create_backup(STATE_FILE)
        closed_for_csv = []
        for trade in list(valid_trades):
            if close_trade_on_binance(bnc, trade, "Panel Close All", state, close_pct=1.0):
                closed_trade_data = next((t for t in reversed(state.get('trade_history', [])) if t['trade_id'] == trade['trade_id']), None)
                if closed_trade_data:
                    closed_for_csv.append(closed_trade_data)
        if closed_for_csv:
            export_trade_history_to_csv(closed_for_csv)
            save_state(state)
            print(f"‚úÖ ƒê√£ x·ª≠ l√Ω ƒë√≥ng {len(closed_for_csv)} l·ªánh.")
        else:
            print("‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh n√†o ƒë∆∞·ª£c ƒë√≥ng th√†nh c√¥ng.")
    finally: release_lock()

def extend_stale_check(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        state = load_state()
        if not state: return
        valid_trades, _ = reconcile_state(bnc, state)
        if not valid_trades: print("‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh h·ª£p l·ªá ƒë·ªÉ gia h·∫°n."); return

        display_list = [f"{t['symbol']}-{t['interval']}" for t in valid_trades]
        trade_to_extend = select_from_list(valid_trades, "üëâ Ch·ªçn l·ªánh c·∫ßn gia h·∫°n: ", display_list)
        if not trade_to_extend: print("H·ªßy."); return

        hours = float(input("üëâ Nh·∫≠p s·ªë gi·ªù mu·ªën gia h·∫°n: "))
        if hours <= 0: print("‚ùå S·ªë gi·ªù ph·∫£i d∆∞∆°ng."); return

        create_backup(STATE_FILE)

        trade_found = False
        for trade in state.get('active_trades', []):
            if trade.get('trade_id') == trade_to_extend.get('trade_id'):
                override_until = datetime.now(VIETNAM_TZ) + timedelta(hours=hours)
                trade['stale_override_until'] = override_until.isoformat()
                trade_found = True
                print(f"\n‚úÖ L·ªánh {trade['symbol']} ƒë√£ gia h·∫°n ƒë·∫øn: {override_until.strftime('%Y-%m-%d %H:%M:%S')}")
                break

        if trade_found:
            save_state(state)
        else:
            print("‚ùå Kh√¥ng t√¨m th·∫•y l·ªánh trong state, c√≥ th·ªÉ ƒë√£ b·ªã thay ƒë·ªïi.")

    except (ValueError, TypeError): print("‚ùå Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.")
    finally: release_lock()

def adopt_orphan_asset(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        print("\n" + "üêæ" * 10 + " CH·ª®C NƒÇNG NH·∫¨N NU√îI T√ÄI S·∫¢N " + "üêæ" * 10)
        print("Ch·ª©c nƒÉng n√†y ƒëƒÉng k√Ω m·ªôt t√†i s·∫£n ƒë√£ c√≥ tr√™n s√†n v√†o h·ªá th·ªëng qu·∫£n l√Ω c·ªßa bot.")
        state = load_state()
        if state is None: return
        account = bnc.get_account_balance()
        if not account: print("‚ùå Kh√¥ng th·ªÉ l·∫•y s·ªë d∆∞."); return
        balances = {b['asset']: float(b['free']) for b in account.get('balances', []) if float(b['free']) > 0}
        env_symbols = parse_env_variable("SYMBOLS_TO_SCAN")
        symbols_in_state = {t['symbol'] for t in state.get("active_trades", [])}
        orphan_assets = []
        for asset, qty in balances.items():
            symbol = f"{asset}USDT"
            if symbol in env_symbols and symbol not in symbols_in_state:
                price = get_current_price(symbol)
                value_usdt = qty * price if price else 0
                if value_usdt >= GENERAL_CONFIG.get('MIN_ORDER_VALUE_USDT', 11.0):
                    orphan_assets.append({'symbol': symbol, 'asset': asset, 'quantity': qty, 'value_usdt': value_usdt})
        if not orphan_assets:
            print("\n‚úÖ Kh√¥ng t√¨m th·∫•y t√†i s·∫£n m·ªì c√¥i n√†o ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ nh·∫≠n nu√¥i."); return

        display_list = [f"{a['asset']} (SL: {a['quantity']:.6f}, Tr·ªã gi√°: ~${a['value_usdt']:,.2f})" for a in orphan_assets]
        asset_to_adopt = select_from_list(orphan_assets, "\nüëâ Ch·ªçn t√†i s·∫£n c·∫ßn nh·∫≠n nu√¥i (Enter ƒë·ªÉ h·ªßy): ", display_list)
        if not asset_to_adopt: return

        print(f"\n--- Nh·∫≠p th√¥ng tin cho l·ªánh {asset_to_adopt['symbol']} ---")
        try:
            entry_price = float(input(f"üëâ Nh·∫≠p gi√° v√†o l·ªánh trung b√¨nh (Entry Price): "))
            total_invested_usd = float(input(f"üëâ Nh·∫≠p t·ªïng v·ªën USDT ƒë√£ ƒë·∫ßu t∆∞ cho l·ªánh n√†y: "))
            interval = select_from_list(INTERVALS, "üëâ Ch·ªçn Interval ƒë·ªÉ bot qu·∫£n l√Ω: ", INTERVALS)
            tactic_name = select_from_list(TACTICS, "üëâ Ch·ªçn Tactic ƒë·ªÉ g√°n: ", TACTICS)
            if not all([entry_price > 0, total_invested_usd > 0, interval, tactic_name]):
                print("‚ùå Th√¥ng tin kh√¥ng h·ª£p l·ªá. H·ªßy thao t√°c."); return
        except (ValueError, TypeError):
            print("‚ùå Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá. H·ªßy thao t√°c."); return

        tactic_cfg = TACTICS_LAB.get(tactic_name, {})
        sl_price = entry_price * (1 - RISK_RULES_CONFIG["MAX_SL_PERCENT_BY_TIMEFRAME"].get(interval, 0.08))
        tp_price = entry_price + ((entry_price - sl_price) * tactic_cfg.get("RR", 2.0))

        new_trade = {
            "trade_id": str(uuid.uuid4()), "symbol": asset_to_adopt['symbol'], "interval": interval,
            "status": "ACTIVE", "opened_by_tactic": tactic_name, "tactic_used": ["Manual_Adoption"],
            "trade_type": "LONG", "entry_price": entry_price, "quantity": asset_to_adopt['quantity'],
            "tp": tp_price, "sl": sl_price, "initial_sl": sl_price,
            "total_invested_usd": total_invested_usd, "entry_time": datetime.now(VIETNAM_TZ).isoformat(),
            "initial_entry": {"price": entry_price, "quantity": asset_to_adopt['quantity'], "invested_usd": total_invested_usd},
            "entry_score": 5.0, "last_score": 5.0, "entry_zone": "Manual", "last_zone": "Manual",
            "dca_entries": [], "realized_pnl_usd": 0.0,
        }

        print("\n" + "="*20 + "\nXEM L·∫†I TH√îNG TIN L·ªÜNH S·∫ÆP T·∫†O:\n" + json.dumps(new_trade, indent=2) + "\n" + "="*20)
        if input("\n‚ö†Ô∏è X√°c nh·∫≠n th√™m l·ªánh n√†y v√†o h·ªá th·ªëng? (y/n): ").lower() != 'y':
            print("H·ªßy thao t√°c."); return

        create_backup(STATE_FILE)
        state['active_trades'].append(new_trade)
        state['money_spent_on_trades_last_session'] = state.get('money_spent_on_trades_last_session', 0.0) + total_invested_usd

        save_state(state)
        print(f"\n‚úÖ ƒê√£ nh·∫≠n nu√¥i th√†nh c√¥ng t√†i s·∫£n {asset_to_adopt['asset']} v√† c·∫≠p nh·∫≠t s·ªï s√°ch!")

    except Exception as e:
        print(f"\nüî•üî• L·ªói khi nh·∫≠n nu√¥i t√†i s·∫£n: {e}"); traceback.print_exc()
    finally: release_lock()

def reconcile_manually(bnc: BinanceConnector):
    if not acquire_lock(): return
    try:
        print("\n--- Ch·ª©c nƒÉng: ƒê·ªìng b·ªô l·∫°i tr·∫°ng th√°i (S·ª≠a 'l·ªánh ma') ---")
        state = load_state()
        if not state: return
        _, desynced_trades = reconcile_state(bnc, state)
        if not desynced_trades:
            print("\n‚úÖ Tr·∫°ng th√°i ƒë√£ ƒë·ªìng b·ªô, kh√¥ng c√≥ 'l·ªánh ma'.")
            return

        create_backup(STATE_FILE)
        print("\n" + "‚ö†Ô∏è" * 5 + " C√ÅC L·ªÜNH B·∫§T ƒê·ªíNG B·ªò ƒê√É T√åM TH·∫§Y " + "‚ö†Ô∏è" * 5)
        for i, trade in enumerate(desynced_trades): print(f"{i+1}. {trade['symbol']}")
        if input("\nüëâ X√≥a c√°c l·ªánh n√†y kh·ªèi danh s√°ch ƒëang m·ªü? (y/n): ").lower() != 'y': return

        trade_ids_to_remove = {t['trade_id'] for t in desynced_trades}
        closed_for_csv = []
        for trade in desynced_trades:
            trade.update({'status': 'Closed (Desynced by Panel)', 'exit_time': datetime.now(VIETNAM_TZ).isoformat(), 'pnl_usd': 0, 'pnl_percent': 0})
            state.setdefault('trade_history', []).append(trade)
            closed_for_csv.append(trade)
        state['active_trades'] = [t for t in state['active_trades'] if t['trade_id'] not in trade_ids_to_remove]

        export_trade_history_to_csv(closed_for_csv)
        save_state(state)
        print(f"‚úÖ ƒê√£ x√≥a {len(closed_for_csv)} 'l·ªánh ma' v√† c·∫≠p nh·∫≠t l·ªãch s·ª≠.")

    finally: release_lock()

def sell_manual_assets(bnc: BinanceConnector):
    print("\n" + "üóëÔ∏è" * 10 + " C√îNG C·ª§ B√ÅN COIN L·∫∫ " + "üóëÔ∏è" * 10)
    print("Ch·ª©c nƒÉng n√†y b√°n coin tr√™n s√†n v√† KH√îNG ·∫£nh h∆∞·ªüng ƒë·∫øn state c·ªßa bot.")
    print("L∆ØU √ù: live_trade s·∫Ω t·ª± ƒë·ªông hi·ªÉu ƒë√¢y l√† m·ªôt kho·∫£n N·∫†P TI·ªÄN, v√¨ t√†i s·∫£n n√†y kh√¥ng thu·ªôc qu·∫£n l√Ω c·ªßa bot.")
    try:
        print("\n... ƒêang l·∫•y s·ªë d∆∞ v√† gi√° t·ª´ Binance...")
        account = bnc.get_account_balance()
        if not account: print("‚ùå Kh√¥ng th·ªÉ l·∫•y s·ªë d∆∞."); return
        balances = {b['asset']: float(b['free']) for b in account.get('balances', []) if float(b['free']) > 0}
        env_symbols = parse_env_variable("SYMBOLS_TO_SCAN")
        env_assets = {s.replace("USDT", "") for s in env_symbols}
        assets_to_check = {asset: qty for asset, qty in balances.items() if asset in env_assets and asset not in ['USDT', 'BNB']}
        if not assets_to_check: print("\n‚úÖ Kh√¥ng t√¨m th·∫•y coin l·∫ª n√†o (trong danh s√°ch .env) ƒë·ªÉ b√°n."); return
    except Exception as e: print(f"\nüî•üî• L·ªói: {e}"); traceback.print_exc()

# --- H√ÄM MAIN V√Ä MENU CH√çNH ---

def main_menu():
    try:
        with BinanceConnector(network=TRADING_MODE) as bnc:
            if not bnc.test_connection(): return
            while True:
                print("\n" + "="*15 + f" üìä B·∫¢NG ƒêI·ªÄU KHI·ªÇN v7.4 (LIVE-{TRADING_MODE.upper()}) üìä " + "="*15)
                print("--- Xem & Ph√¢n t√≠ch ---")
                print(" 1. Dashboard & Radar th·ªã tr∆∞·ªùng")
                print(" 2. Xem 20 giao d·ªãch cu·ªëi t·ª´ CSV")
                print(" 3. Ph√¢n t√≠ch Hi·ªáu su·∫•t Tactic")
                print(" 4. T·∫°o v√† g·ª≠i b√°o c√°o th·ªß c√¥ng")
                print("\n--- H√†nh ƒë·ªông Giao d·ªãch ---")
                print(" 5. M·ªü l·ªánh m·ªõi th·ªß c√¥ng")
                print(" 6. ƒê√≥ng m·ªôt l·ªánh c·ªßa Bot")
                print(" 7. ƒê√≥ng T·∫§T C·∫¢ l·ªánh c·ªßa Bot")
                print(" 8. Gia h·∫°n ki·ªÉm tra cho m·ªôt l·ªánh '√¨'")
                print("\n--- B·∫£o tr√¨ & Ti·ªán √≠ch ---")
                print(" 9. Nh·∫≠n nu√¥i T√†i s·∫£n m·ªì c√¥i")
                print("10. ƒê·ªìng b·ªô l·∫°i State (S·ª≠a 'l·ªánh ma')")
                print("11. B√°n coin l·∫ª tr√™n s√†n (Ngo√†i h·ªá th·ªëng Bot)")
                print("\n 0. Tho√°t")
                print("="*67)

                choice = input("üëâ Vui l√≤ng ch·ªçn m·ªôt ch·ª©c nƒÉng: ")
                menu_actions = {
                    '1': show_full_dashboard, '2': view_csv_history, '3': show_tactic_analysis,
                    '4': manual_report, '5': open_manual_trade, '6': close_manual_trade,
                    '7': close_all_trades, '8': extend_stale_check, '9': adopt_orphan_asset,
                    '10': reconcile_manually, '11': sell_manual_assets,
                }

                if choice == '0':
                    print("üëã T·∫°m bi·ªát!"); break

                action = menu_actions.get(choice)
                if action:
                    if choice in ['1', '4', '5', '6', '7', '8', '9', '10', '11']:
                        action(bnc)
                    else:
                        action()
                else:
                    print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.")
    except Exception as e:
        print(f"\nüî•üî•üî• L·ªói nghi√™m tr·ªçng trong menu ch√≠nh: {e}"); traceback.print_exc()

if __name__ == "__main__":
    signal.signal(signal.SIGINT, handle_exit_signals)
    if sys.platform != "win32":
        try: signal.signal(signal.SIGTSTP, handle_exit_signals)
        except AttributeError: pass
    main_menu()
